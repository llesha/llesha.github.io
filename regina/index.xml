<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reginas on</title><link>https://llesha.github.io/regina/</link><description>Recent content in Reginas on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://llesha.github.io/regina/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://llesha.github.io/regina/typization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/typization/</guid><description>Dynamically typed languages check variable type during runtime, meaning it is more error-prone.On the contrary, statically typed languages check variable type during compilation.</description></item><item><title/><link>https://llesha.github.io/regina/why/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/why/</guid><description>Why I created a programming language TLDR: I didn&amp;rsquo;t think about making a library for dynamic instantiation. I should&amp;rsquo;ve made a library - that is an optimal path.</description></item><item><title>Design decisions</title><link>https://llesha.github.io/regina/design-decisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/design-decisions/</guid><description>Why null is 0? now it is not First, let&amp;rsquo;s provide some context.
I do not find void type useful. Therefore, void == null.</description></item><item><title>Dynamic instantiation</title><link>https://llesha.github.io/regina/dynamic-instantiation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/dynamic-instantiation/</guid><description>TLDR Difference between other languages and ReGIna is dynamic instantiation. In short, properties in classes will be assigned only after their dependencies are assigned, allowing recursive properties of same class A inside class A.</description></item><item><title>Global</title><link>https://llesha.github.io/regina/global/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/global/</guid><description>Global is a file that&amp;rsquo;s imported by default.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 fun print(x): Null { // print `x` into console } fun except(x) { // throws exception with `x` as message } fun input(input): Any { // not working in [IDE]()*.</description></item><item><title>IDE</title><link>https://llesha.github.io/regina/ide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/ide/</guid><description/></item><item><title>ReGIna</title><link>https://llesha.github.io/regina/regina/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/regina/</guid><description>is a dynamically typed language with syntax similar to Kotlin and Python.
Documentation It is highly recommended to read in following order, don&amp;rsquo;t click on links in articles for the first time:</description></item><item><title>std/math.rgn</title><link>https://llesha.github.io/regina/std/math/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/std/math/</guid><description>Functions rndInt</description></item><item><title>Syntax</title><link>https://llesha.github.io/regina/syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/syntax/</guid><description>Table of Contents Top level declarations Class Object Function Imports Operators Boolean operators Boolean values Arithmetic operators Ternary operator Property/variable assignment References Cycles while foreach Foreach in list Foreach in String Foreach in range 1.</description></item><item><title>Table of operator precedence</title><link>https://llesha.github.io/regina/toop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/toop/</guid><description>Table of operator precedence Operator Description postfix: (), [], . change operators' precedence with parentheses takes element from array or string gets property of class prefix: !</description></item><item><title>Things that hopefully you will never encounter</title><link>https://llesha.github.io/regina/advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/advanced/</guid><description>But are good to know anyway.
Dictionary mutable key 1 2 3 4 5 6 7 8 9 10 11 fun main() { a = [1] t = {a: &amp;#34;value&amp;#34;} print(t) print(t[[1]]) a.</description></item><item><title>Types</title><link>https://llesha.github.io/regina/types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/types/</guid><description>Table of Contents Value types Reference types Null Number Documentation Boolean Int Documentation Double Documentation String Documentation List Documentation Dictionary Documentation Examples Type properties Constructor Inheritance Object There are three value types and three reference types.</description></item><item><title>Visibility scopes</title><link>https://llesha.github.io/regina/scopes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/regina/scopes/</guid><description>Table of Contents Global scope Class instance scope Function scope Block scope Accessing declarations with same names Import priority Using functions with same signature All scopes, sorted from the most visible to the least:</description></item></channel></rss>