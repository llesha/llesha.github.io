<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programmings on</title><link>https://llesha.github.io/programming/</link><description>Recent content in Programmings on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://llesha.github.io/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Abstract Syntax Tree</title><link>https://llesha.github.io/programming/ast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/ast/</guid><description>Abstract Syntax Tree (AST) is key concept in program evaluation. It is a tree with tokens as its nodes. Tree is a better structure than sequence.</description></item><item><title>Basic memory management</title><link>https://llesha.github.io/programming/heap-and-stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/heap-and-stack/</guid><description>Last fall, I had an interview. They asked me about differences between heap and stack, how references and variables are stored.</description></item><item><title>C#: Boxing, unboxing and equality operator</title><link>https://llesha.github.io/programming/boxing-and-equality-cs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/boxing-and-equality-cs/</guid><description>Boxing / unboxing Boxing/unboxing has to do with reference and value types. Value types store their values on stack (usually primitives).</description></item><item><title>C++ Memory model</title><link>https://llesha.github.io/programming/cpp-pointers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/cpp-pointers/</guid><description>Memory is a two column table. First row contains addresses, second row contains values.
1 int x = 4; When variable is assigned, an empty memory row cell is chosen.</description></item><item><title>Devlog 1. Bad globals</title><link>https://llesha.github.io/programming/devlog1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/devlog1/</guid><description>What is a symbol table? Symbol table stores current program state. I separated it into three levels, turning SymbolTable into a kind of manager-facade:</description></item><item><title>Devlog 2. Link class. Removing state</title><link>https://llesha.github.io/programming/devlog2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/devlog2/</guid><description>Link class is for evaluating links. A link is a statement in form of a.b.c, where all expressions after dots (in this case b and c) are either identifiers1, indexes2 or invocations3.</description></item><item><title>How languages are run?</title><link>https://llesha.github.io/programming/transpilers-compilers-interpreters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/transpilers-compilers-interpreters/</guid><description>People in the programing languages field use fancy buzzwords like translator, transpiler, compiler, interpreter, JIT (just in time) compiler. Let&amp;rsquo;s figure out what they mean.</description></item><item><title>Introduction to grammars</title><link>https://llesha.github.io/programming/introduction-to-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/introduction-to-grammars/</guid><description>Grammar defines a set of strings (words), which is called a language. Essentially grammar is a Dictionary &amp;lt;String, String&amp;gt;, where each dictionary entry is a grammar rule.</description></item><item><title>Making tex to html CV translator</title><link>https://llesha.github.io/programming/making-tex-to-html-cv-translator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/making-tex-to-html-cv-translator/</guid><description>Motivation For about a year, I had CV made with LaTeX in Overleaf (online LaTeX editor). But I found it cumbersome to import new versions to Google Drive when CV was updated.</description></item><item><title>Multithreading. Primitive tools, definitions</title><link>https://llesha.github.io/programming/multithreading1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/multithreading1/</guid><description>First, let&amp;rsquo;s clarify some definitions (I won&amp;rsquo;t go too deep into that):
Process Process is a running program, that has its own address space in memory (most of it is heap).</description></item><item><title>Multithreading. Problems, Object methods</title><link>https://llesha.github.io/programming/multithreading2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/multithreading2/</guid><description>Thread problems Thread problems have names. Here are the most popular ones.
Deadlock N locks locked forever, waiting for each other.</description></item><item><title>Parsers</title><link>https://llesha.github.io/programming/parsers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/parsers/</guid><description>As with the first article, I wrote this one on a computer, because the topic is hard to tackle. I knew I would have to make a lot of edits and rearrangements.</description></item><item><title>Programming notes</title><link>https://llesha.github.io/programming/programming-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/programming-notes/</guid><description>Links to all articles:
2022 28 June: Heap and Stack
29 June: How languages are run?
30 June: Abstract syntax tree</description></item><item><title>Quality of life</title><link>https://llesha.github.io/programming/quality-of-life/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/quality-of-life/</guid><description>Recently I started working on a new project, that also requires creating a custom programming language. I noticed a significant difference with changing my approach: now I use python and Lark for parsing EBNF.</description></item><item><title>Shallow villain traits</title><link>https://llesha.github.io/programming/shallow-villain-traits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/shallow-villain-traits/</guid><description/></item><item><title>SQL</title><link>https://llesha.github.io/programming/SQL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/SQL/</guid><description>created from this free course
Table of Contents Definitions Statements Create Select Insert into Alter table Update Delete from Order by Limit Case Group by Having Constraints Data types WHERE operators Wildcards Aggregates Count Sum Max, min, avg Round Multiple tables Join Foreign key Left join Cross join Union With Other keywords IFNULL OFFSET IN Functions DATE_ADD Definitions Table a.</description></item><item><title>Why game making is not for me</title><link>https://llesha.github.io/programming/why-gamemaking-is-not-for-me/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://llesha.github.io/programming/why-gamemaking-is-not-for-me/</guid><description>TLDR: it is frustrating, initial idea and result have a huge difference, because I associate my game ideas with emotions, that a player feels during the game.</description></item></channel></rss>