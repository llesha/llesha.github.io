<!doctype html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="icon" type="image/svg+xml" href="//localhost:1313/svg/icon.svg">
  <script src="//localhost:1313/js/loader.js"></script>
  <meta name="generator" content="Hugo 0.123.1">
  <link rel="stylesheet" href="//localhost:1313/css/colors.css"><link rel="stylesheet" href="//localhost:1313/css/styles.css">
  
  
  <title>Basic memory management | llesha</title>
  <script type="module" src="//localhost:1313/js/interactive.js"></script>
</head>

<body>
  <div id="nav-border" class="container">
  <nav id="nav" class="nav justify-content-center">
    <div style="text-align: center; font-size: larger;">
      
      
      <a class="nav-link" href="/">Home</a>
      
      
      <a class="nav-link" href="/projects/">Projects</a>
      
      
      <a class="nav-link" href="/tags/">Tags</a>
      
    </div>
    <button id="change-theme-button">dark</button>
    <div style="justify-content: center;">
      <a href="https://github.com/llesha">GitHub</a>
      <a href="https://stackoverflow.com/users/19933941/llesha">StackOverflow</a>
      <a href="https://www.linkedin.com/in/llesha">LinkedIn</a>
    </div>
  </nav>
</div>
  <main id="main">
    

<h1>Basic memory management</h1>




<i data-feather="calendar"></i> <time datetime="2022-06-28">28 June 2022</time>



<br><br>
<p><em>Last fall, I had an interview.
They asked me about differences between heap and stack, how
references and variables are stored.
I was confident that I knew all this stuff.
Apparently, I was wrong.</em></p>
<h1 id="commonalities">Commonalities</h1>
<p>Both stack and heap use RAM.</p>
<h1 id="stack">Stack</h1>
<p>Stack is a LIFO static<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> storage that contains:</p>
<ul>
<li>Local primitive variables</li>
<li>References to non-primitive variables</li>
<li>Method parameters</li>
<li>Sequence of method calls (hence, each thread has its own stack. Also, this is the reason why
infinite recursion will result in stack overflow error)</li>
</ul>
<p>When the method finishes its execution, a stack is emptied with one assembly command - moving
the pointer to stack head. Therefore, a stack returns to the state before that method&rsquo;s call.</p>
<h3 id="primitive-variables">Primitive variables</h3>
<p>Local primitive variables are stored in stack. Primitive fields of an object instance are stored in
heap.</p>
<h1 id="heap">Heap</h1>
<p>Heap is a dynamic memory structure that stores non-primitive variables. References (pointers to
variable address in the heap) to these variables are in the stack.</p>
<p>Unlike stack, heap is commonly shared between threads. Consequently, one object shouldn&rsquo;t be
modified simultaneously from different threads.</p>
<p>Out of memory error is possible for the heap too.</p>
<h3 id="garbage-collector-and-cc-features">Garbage collector and C/C++ features</h3>
<p>Some languages (Java, C#) handle memory automatically. A component responsible for it is called
garbage collector. Fallback of this approach is unexpected runtime slowdowns due to garbage
collector managing memory.</p>
<p>Other languages (C/C++) pass this responsibility on to programmer. In C++ every <code>new</code> keyword
should
be followed by <code>delete</code> to prevent memory leak. Additionally, it is possible to store object
instance on stack in C++, if variable is declared without <code>new</code>. Such local variable will
be popped from stack after method
execution. <a href="programming/cpp-pointers">A little more about C++ memory model</a>.</p>
<h3 id="heap-fragmentation">Heap fragmentation</h3>
<p>Heap is a single block of memory. When some memory from heap is released, a chunk of unused memory
is formed. After many iterations heap becomes a bunch of alternating fragments of used and unused
memory.</p>
<p>Essentially this is an inefficient memory utilization, because overall there might be $n$
bytes of free memory, however not all bytes can be allocated. It is possible to allocate no more
bytes than there are in the biggest consecutive chunk of free memory.</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 140.199 50.241"><path d="M33.262 39.876h18.521v46.302H33.262z" style="fill:var(--dark);fill-opacity:1;stroke:#000;stroke-width:2.616;stroke-linecap:round;stroke-opacity:0" transform="translate(-12.3 -38.002)"/><path d="M68.708 40.454h28.138v45.714H68.708z" style="fill:var(--dark);fill-opacity:1;stroke:#000;stroke-width:3.20392;stroke-linecap:round;stroke-opacity:0" transform="translate(-12.3 -38.002)"/><path d="M127.509 39.951h7.633v45.714h-7.633z" style="fill:var(--dark);fill-opacity:1;stroke:#000;stroke-width:1.66872;stroke-linecap:round;stroke-opacity:0" transform="translate(-12.3 -38.002)"/><path d="M136.79 40.371h9.225v45.552h-9.225z" style="fill:var(--dark);fill-opacity:1;stroke:#000;stroke-width:1.83125;stroke-linecap:round;stroke-opacity:0" transform="translate(-12.3 -38.002)"/><path d="M108.78 40.475h12.521v45.256H108.78z" style="fill:var(--dark);fill-opacity:1;stroke:var(--secondary);stroke-width:2.12649;stroke-linecap:round;stroke-opacity:0" transform="translate(-12.3 -38.002)"/><path fill="none" d="M13.607 39.31H151.19v47.625H13.607z" style="fill:#253092;fill-opacity:0;stroke:var(--comment);stroke-width:2.616;stroke-linecap:round;stroke-opacity:1" transform="translate(-12.3 -38.002)"/></svg>
<p><em>After some time heap looks like a barcode (white is free memory, black is unused memory)</em></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>some languages allow stack reallocation&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>



  </main>
</body>

</html>