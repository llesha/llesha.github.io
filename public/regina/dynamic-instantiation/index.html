<!DOCTYPE html>
<html lang="en">

<body>
<div class="singlePage">
    <link rel="stylesheet" href="css/colors.css"><link rel="stylesheet" href="css/styles.css">
<button id="change-theme-button">dark</button>
    <article>
      <h1>Dynamic instantiation</h1>
      <p class="meta">
        
        <h2 id="tldr">TLDR</h2>
<p>Difference between other languages and ReGIna is dynamic instantiation. In
short, properties in classes will be assigned only after their dependencies are assigned, allowing
recursive properties
of same class <code>A</code> inside class <code>A</code>.</p>
<h2 id="idea">Idea</h2>
<p>Classes can have references to other classes inside them as
properties. These property-classes are evaluated dynamically. Take a look at this example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> export rect {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// export = false - can deny export
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    iter = <span style="color:#66d9ef">if</span> (parent) parent.iter + <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    childNode = <span style="color:#66d9ef">if</span> (iter <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) Nothing() <span style="color:#66d9ef">else</span> Node()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    position = <span style="color:#66d9ef">if</span> (childNode <span style="color:#66d9ef">is</span> Node) \
</span></span><span style="display:flex;"><span>    Position(childNode.position.x + <span style="color:#ae81ff">1</span>, childNode.position.y) \
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> Position(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Node()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This will create following svg:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-svg" data-lang="svg"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;svg&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;rect</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;rect</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;3&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;rect</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;2&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;rect</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;rect</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/svg&gt;</span>
</span></span></code></pre></div><p>First algorithm creates empty Node() (we&rsquo;ll call it <em>Node0</em>) from main(). Then, starting from top
to bottom:</p>
<ol>
<li>algorithm assigns <strong>iter</strong> of <em>Node0</em> to 0 because parent returns 0 as an equivalent of null.</li>
<li>After that, <strong>childNode</strong> is assigned a new Node (<em>Node1</em>).</li>
<li><strong>position</strong> cannot be assigned because <strong>childNode.position</strong> is not yet assigned. Algorithm
goes to
childNode.position, that is <em>Node1</em>.position and tries to assign it. However, childNode is
required, so we go to *
Node1*.childNode, which needs iter.</li>
</ol>
<p><em>It&rsquo;s not important to consider while assigning values, but it shows why there cannot be any cyclic
dependencies for properties</em>.</p>
<h2 id="how-not-to-write-code-with-dynamic-instantiation">How not to write code with dynamic instantiation</h2>
<h3 id="bad-class-function">Bad class function</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FunctionOveruse</span> {
</span></span><span style="display:flex;"><span>    prop = make()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">make</span>() {
</span></span><span style="display:flex;"><span>        FunctionOveruse()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> prop
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Both lines in <code>make()</code> will execute forever.</p>
<p>To make functions as expressive as possible, it is important to allow class instantiating inside
them. If</p>
<p>We either make internal class functions (which is purely decompositional thing) or make
instantiating inside functions
possible (and <code>fun main()</code> as an entry point)</p>

      </p>
      <ul class="tags">
          
      </ul>
    </article>
    <footer>
    Made by llesha Â© 2024
</footer>
<script type="module" src="js/loader.js"></script>

</div>
</body>
</html>
